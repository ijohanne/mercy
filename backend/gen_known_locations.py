#!/usr/bin/env python3
"""Generate src/known_locations.rs from historical spawn data (assets/known_locations.csv)."""

from collections import defaultdict
from pathlib import Path

CELL_SIZE = 25
SCRIPT_DIR = Path(__file__).parent
CSV_PATH = SCRIPT_DIR / "assets" / "known_locations.csv"
OUTPUT_PATH = SCRIPT_DIR / "src" / "known_locations.rs"


def main():
    kingdom_locs = defaultdict(list)
    with open(CSV_PATH) as f:
        for line in f:
            parts = line.strip().split(",")
            if len(parts) == 3:
                k, x, y = int(parts[0]), int(parts[1]), int(parts[2])
                kingdom_locs[k].append((x, y))

    # For each kingdom: cluster into viewport-sized cells, sort by density
    kingdom_positions = {}
    for k, locs in sorted(kingdom_locs.items()):
        cells = defaultdict(int)
        for x, y in locs:
            cx = min((x // CELL_SIZE) * CELL_SIZE + CELL_SIZE // 2, 1023)
            cy = min((y // CELL_SIZE) * CELL_SIZE + CELL_SIZE // 2, 1023)
            cells[(cx, cy)] += 1

        sorted_cells = sorted(cells.items(), key=lambda item: -item[1])
        kingdom_positions[k] = sorted_cells

    lines = []
    lines.append("// Auto-generated by gen_known_locations.py â€” do not edit manually.")
    lines.append(f"// Source: assets/known_locations.csv ({sum(len(v) for v in kingdom_locs.values())} records, {len(kingdom_locs)} kingdoms)")
    lines.append(f"// Cell size: {CELL_SIZE}x{CELL_SIZE} game units (viewport-aligned)")
    lines.append("")
    lines.append("/// Density-sorted scan positions with spawn counts for a kingdom.")
    lines.append("/// Each entry is (x, y, spawn_count) where x,y is the center of a")
    lines.append(f"/// {CELL_SIZE}x{CELL_SIZE} game-unit cell, ordered by descending spawn count.")
    lines.append("/// The spawn count enables runtime coverage-percentage cutoffs.")
    lines.append("/// Returns an empty slice for kingdoms without historical data.")
    lines.append("pub fn positions_for_kingdom(kingdom: u32) -> &'static [(u32, u32, u16)] {")
    lines.append("    match kingdom {")

    for k, positions in sorted(kingdom_positions.items()):
        entries = ", ".join(f"({x}, {y}, {cnt})" for (x, y), cnt in positions)
        lines.append(f"        {k} => &[{entries}],")

    lines.append("        _ => &[],")
    lines.append("    }")
    lines.append("}")
    lines.append("")

    # Stats table
    lines.append("/// Number of scan positions per known kingdom (for diagnostics).")
    lines.append("#[allow(dead_code)]")
    lines.append("pub const KINGDOM_STATS: &[(u32, u16, u16)] = &[")
    lines.append("    // (kingdom, historical_spawns, scan_positions)")

    for k in sorted(kingdom_positions.keys()):
        total_spawns = len(kingdom_locs[k])
        n_positions = len(kingdom_positions[k])
        lines.append(f"    ({k}, {total_spawns}, {n_positions}),")

    lines.append("];")
    lines.append("")

    OUTPUT_PATH.write_text("\n".join(lines))
    total_positions = sum(len(v) for v in kingdom_positions.values())
    print(f"Generated {OUTPUT_PATH}: {len(kingdom_positions)} kingdoms, {total_positions} total positions")


if __name__ == "__main__":
    main()
